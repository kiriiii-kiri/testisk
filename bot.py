import asyncio
import logging
import os
from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.enums import ParseMode
from aiogram.webhook.aiohttp_server import SimpleRequestHandler, setup_application
from aiohttp import web
from game import Game
from database import init_db, get_user_record, update_user_record, get_top_players

# üî• –ì–ê–†–ê–ù–¢–ò–†–û–í–ê–ù–ù–û –ß–ò–°–¢–´–ô URL ‚Äî –û–ë–†–ï–ó–ê–ï–ú –ü–†–û–ë–ï–õ–´!
BOT_TOKEN = os.environ.get("BOT_TOKEN", "8498252537:AAFS94y2DJEUOVjOZHx0boHiVvbMrV1T7dc")
WEBHOOK_URL = os.environ.get("WEBHOOK_URL", "https://testisk-zmeika.onrender.com/webhook").strip()
PORT = int(os.environ.get('PORT', 10000))

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

bot = Bot(token=BOT_TOKEN)
dp = Dispatcher()

init_db()
# üî• –§–ò–ö–°: –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–ª–æ–≤–∞—Ä—å —Å –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞–º–∏ –¥–ª—è –ø–æ—Ç–æ–∫–æ–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
active_games = {}
game_locks = {}  # user_id -> asyncio.Lock

def get_user_lock(user_id: int) -> asyncio.Lock:
    if user_id not in game_locks:
        game_locks[user_id] = asyncio.Lock()
    return game_locks[user_id]

@dp.message(Command("start"))
async def start_handler(message: types.Message):
    kb = [
        [InlineKeyboardButton(text="‚ñ∂Ô∏è –ù–∞—á–∞—Ç—å –∏–≥—Ä—É", callback_data="start_game")],
        [InlineKeyboardButton(text="üèÜ –†–µ–∫–æ—Ä–¥—ã", callback_data="show_leaderboard")],
        [InlineKeyboardButton(text="üéñÔ∏è –î–æ—Å—Ç–∏–∂–µ–Ω–∏—è", callback_data="show_achievements")]
    ]
    await message.answer(
        "üêç *Snake RPG Evolution*\n\n–°—ä–µ–¥–∞–π –µ–¥—É, –∏–∑–±–µ–≥–∞–π –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π, —Å–æ–±–∏—Ä–∞–π –±–æ–Ω—É—Å—ã –∏ –º–æ–±–æ–≤!\n–ß–µ–º –¥–ª–∏–Ω–Ω–µ–µ –∑–º–µ—è ‚Äî —Ç–µ–º —Å–∏–ª—å–Ω–µ–µ —Ç—ã —Å—Ç–∞–Ω–æ–≤–∏—à—å—Å—è.\n\n–í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=kb),
        parse_mode=ParseMode.MARKDOWN
    )

@dp.callback_query(lambda c: c.data == "start_game")
async def start_game(callback: types.CallbackQuery):
    user_id = callback.from_user.id
    logger.info(f"üéÆ [USER {user_id}] –ù–∞–∂–∞—Ç–∞ –∫–Ω–æ–ø–∫–∞ '–ù–∞—á–∞—Ç—å –∏–≥—Ä—É'")
    await callback.answer()

    username = callback.from_user.username or f"User{user_id}"
    game = Game(user_id, username)
    active_games[user_id] = game

    board = game.render_board()
    status = f"\n–û—á–∫–∏: {game.score} üéØ | –î–ª–∏–Ω–∞: {len(game.snake)} üêç | –£—Ä–æ–≤–µ–Ω—å: {game.level_name}"
    await callback.message.answer(
        f"```\n{board}\n```\n{status}",
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=await get_control_keyboard()
    )

async def get_control_keyboard():
    kb = [
        [InlineKeyboardButton(text="‚¨ÜÔ∏è", callback_data="move_up")],
        [
            InlineKeyboardButton(text="‚¨ÖÔ∏è", callback_data="move_left"),
            InlineKeyboardButton(text="‚¨áÔ∏è", callback_data="move_down"),
            InlineKeyboardButton(text="‚û°Ô∏è", callback_data="move_right")
        ]
    ]
    return InlineKeyboardMarkup(inline_keyboard=kb)

@dp.callback_query(lambda c: c.data.startswith("move_"))
async def handle_move(callback: types.CallbackQuery):
    user_id = callback.from_user.id
    logger.info(f"üêç [USER {user_id}] –î–≤–∏–∂–µ–Ω–∏–µ: {callback.data}")

    lock = get_user_lock(user_id)
    async with lock:
        if user_id not in active_games:
            await callback.answer("‚ùó –ò–≥—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ù–∞—á–Ω–∏ –Ω–æ–≤—É—é!", show_alert=True)
            return

        game = active_games[user_id]
        if not game.is_alive:
            await callback.answer("üíÄ –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! –ù–∞—á–Ω–∏ –∑–∞–Ω–æ–≤–æ.", show_alert=True)
            return

        direction = callback.data.split("_")[1]
        game.move(direction)

        board = game.render_board()
        status = f"\n–û—á–∫–∏: {game.score} üéØ | –î–ª–∏–Ω–∞: {len(game.snake)} üêç | –£—Ä–æ–≤–µ–Ω—å: {game.level_name}"

        try:
            await callback.message.edit_text(
                f"```\n{board}\n```\n{status}",
                parse_mode=ParseMode.MARKDOWN
            )
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: {e}")

        if not game.is_alive:
            record_updated = update_user_record(game.user_id, game.username, game.score)
            achievements = check_achievements(game)
            msg = f"üíÄ *GAME OVER*\n\n–û—á–∫–∏: {game.score}\n–î–ª–∏–Ω–∞: {len(game.snake)}"
            if record_updated:
                msg += "\n\nüèÜ *–ù–æ–≤—ã–π –ª–∏—á–Ω—ã–π —Ä–µ–∫–æ—Ä–¥!*"
            if achievements:
                msg += "\n\nüéñÔ∏è *–ù–æ–≤—ã–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è:*\n" + "\n".join(achievements)

            kb = [[InlineKeyboardButton(text="üîÑ –ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞", callback_data="start_game")]]
            try:
                await callback.message.edit_text(
                    msg,
                    reply_markup=InlineKeyboardMarkup(inline_keyboard=kb),
                    parse_mode=ParseMode.MARKDOWN
                )
            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∫–∞–∑–µ Game Over: {e}")
            del active_games[user_id]
            return

@dp.callback_query(lambda c: c.data == "show_leaderboard")
async def show_leaderboard(callback: types.CallbackQuery):
    await callback.answer()
    top_players = get_top_players()
    msg = "üèÜ *–¢–æ–ø-10 –∏–≥—Ä–æ–∫–æ–≤:*\n\n" + "\n".join(f"{i}. @{username} ‚Äî {score} –æ—á–∫–æ–≤" for i, (username, score) in enumerate(top_players, 1))
    kb = [[InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="start_game")]]
    await callback.message.edit_text(msg, reply_markup=InlineKeyboardMarkup(inline_keyboard=kb), parse_mode=ParseMode.MARKDOWN)

@dp.callback_query(lambda c: c.data == "show_achievements")
async def show_achievements(callback: types.CallbackQuery):
    await callback.answer()
    msg = "üéñÔ∏è *–î–æ—Å—Ç–∏–∂–µ–Ω–∏—è:*\n\n1. üå± *–ù–æ–≤–∏—á–æ–∫* ‚Äî –Ω–∞–±—Ä–∞—Ç—å 10 –æ—á–∫–æ–≤\n2. üêâ *–û—Ö–æ—Ç–Ω–∏–∫* ‚Äî —Å—ä–µ—Å—Ç—å 5 –º–æ–±–æ–≤\n3. üíé *–ö–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–µ—Ä* ‚Äî —Å–æ–±—Ä–∞—Ç—å 3 —Ä–∞–∑–Ω—ã—Ö –±–æ–Ω—É—Å–∞\n4. üßó *–ê–ª—å–ø–∏–Ω–∏—Å—Ç* ‚Äî –ø—Ä–æ–π—Ç–∏ —É—Ä–æ–≤–µ–Ω—å '–ü–µ—â–µ—Ä–∞'\n5. üå≥ *–ü–æ–∫–æ—Ä–∏—Ç–µ–ª—å –ª–µ—Å–æ–≤* ‚Äî –ø—Ä–æ–π—Ç–∏ —É—Ä–æ–≤–µ–Ω—å '–õ–µ—Å'"
    kb = [[InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="start_game")]]
    await callback.message.edit_text(msg, reply_markup=InlineKeyboardMarkup(inline_keyboard=kb), parse_mode=ParseMode.MARKDOWN)

def check_achievements(game: 'Game') -> list:
    a = []
    if game.score >= 10: a.append("üå± –ù–æ–≤–∏—á–æ–∫")
    if game.mobs_eaten >= 5: a.append("üêâ –û—Ö–æ—Ç–Ω–∏–∫")
    if len(game.bonuses_collected) >= 3: a.append("üíé –ö–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–µ—Ä")
    if game.level == 2: a.append("üßó –ê–ª—å–ø–∏–Ω–∏—Å—Ç")
    if game.level == 3: a.append("üå≥ –ü–æ–∫–æ—Ä–∏—Ç–µ–ª—å –ª–µ—Å–æ–≤")
    return a

@dp.message()
async def any_message(message: types.Message):
    await message.answer("–ù–∞–∂–º–∏ /start –¥–ª—è –Ω–∞—á–∞–ª–∞ –∏–≥—Ä—ã!")

async def health_check(request):
    """Health check endpoint –¥–ª—è Render"""
    return web.Response(text="OK", status=200)

async def on_startup():
    logger.info("üîÑ [SYSTEM] –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞...")
    logger.info("üóëÔ∏è [SYSTEM] –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –≤–µ–±—Ö—É–∫...")
    await bot.delete_webhook(drop_pending_updates=True)
    await asyncio.sleep(1)

    webhook_info = await bot.get_webhook_info()
    logger.info(f"üì° [SYSTEM] –¢–µ–∫—É—â–∏–π –≤–µ–±—Ö—É–∫: '{webhook_info.url}'")

    if webhook_info.url != WEBHOOK_URL:
        logger.info(f"üîó [SYSTEM] –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–æ–≤—ã–π –≤–µ–±—Ö—É–∫: {WEBHOOK_URL}")
        result = await bot.set_webhook(WEBHOOK_URL)
        if result:
            logger.info("‚úÖ [SYSTEM] –í–µ–±—Ö—É–∫ —É—Å–ø–µ—à–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!")
        else:
            logger.error("‚ùå [SYSTEM] –ù–µ —É–¥–∞–ª–æ—Å—å —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤–µ–±—Ö—É–∫!")
    else:
        logger.info("‚úÖ [SYSTEM] –í–µ–±—Ö—É–∫ —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.")

async def on_shutdown():
    logger.info("üëã [SYSTEM] –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã...")
    await bot.delete_webhook()
    logger.info("üóëÔ∏è [SYSTEM] –í–µ–±—Ö—É–∫ —É–¥–∞–ª—ë–Ω.")

async def main():
    dp.startup.register(on_startup)
    dp.shutdown.register(on_shutdown)

    # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –≤–µ–±-—Å–µ—Ä–≤–µ—Ä–∞ –¥–ª—è –≤–µ–±—Ö—É–∫–∞
    app = web.Application()
    
    # –î–æ–±–∞–≤–ª—è–µ–º health check endpoint
    app.router.add_get('/health', health_check)
    app.router.add_get('/', health_check)  # –¢–∞–∫–∂–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–æ—Ä–Ω–µ–≤–æ–π –ø—É—Ç—å
    
    webhook_requests_handler = SimpleRequestHandler(
        dispatcher=dp,
        bot=bot,
    )
    webhook_requests_handler.register(app, path="/webhook")
    setup_application(app, dp, bot=bot)
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º aiohttp —Å–µ—Ä–≤–µ—Ä
    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, host="0.0.0.0", port=PORT)
    await site.start()
    
    logger.info(f"üöÄ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É {PORT} —Å –≤–µ–±—Ö—É–∫–æ–º {WEBHOOK_URL}")
    logger.info("üîç Health check –¥–æ—Å—Ç—É–ø–µ–Ω –ø–æ /health –∏ /")
    
    # –ë–µ—Å–∫–æ–Ω–µ—á–Ω–æ–µ –æ–∂–∏–¥–∞–Ω–∏–µ —Å –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–º–∏ –ª–æ–≥–∞–º–∏
    try:
        while True:
            await asyncio.sleep(300)  # –õ–æ–≥–∏—Ä—É–µ–º –∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç
            logger.info("ü§ñ –ë–æ—Ç –∞–∫—Ç–∏–≤–µ–Ω –∏ —Ä–∞–±–æ—Ç–∞–µ—Ç...")
    except asyncio.CancelledError:
        logger.info("üëã –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è")

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("üëã –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
